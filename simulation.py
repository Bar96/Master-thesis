from netNMFsc.classes import netNMFGD
from netNMFsc.utils import reorder
import random_walks

import pandas
import random
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import mmread
from sklearn import cluster
from sklearn import metrics
from sklearn.manifold import TSNE


def load_labels(directory):
	'''Load the labels of a simulated dataset generated by splatter

    Parameters
    ----------
    directory : string
        name of the file to load.

    Returns
    -------
    labels : numpy array
        labels.

    '''
	labels_str = pandas.read_csv(directory)
	labels_str = labels_str.drop('Unnamed: 0', axis=1)
	labels_str = labels_str.to_numpy()
	labels = []
	for i in range(labels_str.shape[0]):
		if labels_str[i] == "Group1": labels.append(0)
		elif labels_str[i] == "Group2": labels.append(1)
		elif labels_str[i] == "Group3": labels.append(2)
		elif labels_str[i] == "Group4": labels.append(3)
		elif labels_str[i] == "Group5": labels.append(4)
		elif labels_str[i] == "Group6": labels.append(5)
	return np.array(labels)    
    

def generate_subnetwork(full_network, full_netgenes, subnet_dim=5000):
	'''Generate a random subnetwork from the given network

    Parameters
    ----------
    full_network : numpy array
        input full network.
    full_netgenes : numpy array
        genes in the input full network.
    subnet_dim : integer, optional
        dimension of the subnetwork to generate. The default is 5000.

    Returns
    -------
    subnet : numpy array
        generated subnetwork.
    subnet_netgenes : numpy array
        genes in the subnetwork.

    '''
	subnet = np.zeros([subnet_dim, subnet_dim], dtype=np.float32)
	subnet_netgenes = []

	index_list = [i for i in range(full_network.shape[0])]
	sel_indices = []
	for i in range(subnet_dim):
		rnd_idx = random.randint(0, len(index_list)-1)
		elem = index_list[rnd_idx]
		sel_indices.append(elem)
		index_list.remove(elem)

	sel_indices = sorted(sel_indices)

	for i in range(subnet_dim):
		subnet_netgenes.append(full_netgenes[sel_indices[i]])
		for j in range(i+1, subnet_dim):
			idx1 = sel_indices[i]
			idx2 = sel_indices[j]        
			if full_network[idx1][idx2] > 0:
				subnet[i][j] = full_network[idx1][idx2]   
				subnet[j][i] = full_network[idx1][idx2]
				
	subnet_netgenes = np.array(subnet_netgenes)    
	return subnet, subnet_netgenes


if __name__ == "__main__": 
    
	#load the full coexpedia network
	print('Loading data...')
	netgenes = np.load('data/network/coexpedia_gene_names_mouse.npy')
	network = mmread('data/network/coexpedia_network_mouse.mtx').astype('float32').toarray()
    
	#load the simulated dataset
	dataframe = pandas.read_csv('data/sim_dataset/mESC1.csv')
	dataframe = dataframe.drop('Unnamed: 0', axis=1)
	X = dataframe.to_numpy().astype('float32')
	genes = np.load('data/sim_dataset/genes1.npy')
	del dataframe
  
    #load the labels
	labels = load_labels('data/sim_dataset/labels1.csv')    
    
    #generate a random subnetwork
	print('Generating a random subnetwork...')
	subnet, subnet_netgenes = generate_subnetwork(network, netgenes)	

	#reorder the generated subnetwork
	network_reord = reorder(genes, subnet_netgenes, subnet, 0.0)
	
	#compute the random walks
	print('Generating random walks...')
	n_walks = 20    
	walks = random_walks.sequential_random_walks(network_reord, walk_per_node=n_walks, walk_length=20, verbose=False)
	walks_np = np.array(walks)
	prob_matrix = random_walks.build_probability_matrix(walks, n_walks, X.shape[0])


  
    #define the model with the Laplacian
	dimensions = 10
	reg_par = 10
	n_inits = 1
	max_iters = 1000
	n_jobs = 1
	operator1 = netNMFGD(d=dimensions, alpha=reg_par, n_inits=n_inits, 
    	max_iter=max_iters, n_jobs=n_jobs, sparsity=0.0, tol=5000, use_prob_matrix=False)
    
	operator1.X = X
	operator1.genes = genes
	operator1.N = subnet #load the random generated subnetwork in the model
	operator1.netgenes = subnet_netgenes
	print('Training the model with the network Laplacian...')
    #fit the model
	W, H = operator1.fit_transform()
    
   	#compute the clustering
	H_t = H.transpose()
	kmeans = cluster.KMeans(n_clusters=6).fit(H_t)
	predicted_labels = kmeans.labels_
    
    #compute the ARI
	ari = metrics.adjusted_rand_score(labels, predicted_labels)
	print("ARI with network laplacian: "+str(ari))
	
	#plot results
	points = TSNE(n_components=2, random_state=1).fit_transform(H_t)
	plt.scatter(points[:, 0], points[:, 1], c=predicted_labels, s=1, cmap='viridis')
	plt.title('Predicted labels with Laplacian')
	plt.show()
	
	
	
	#define the model with the probability matrix
	dimensions = 10
	reg_par = 10
	n_inits = 1
	max_iters = 1000
	n_jobs = 1
	operator2 = netNMFGD(d=dimensions, alpha=reg_par, n_inits=n_inits, 
    	max_iter=max_iters, n_jobs=n_jobs, sparsity=0.0, tol=5000, use_prob_matrix=True)
    
	operator2.X = X
	operator2.genes = genes
	operator2.N = prob_matrix #load the probability matrix in the model
	operator2.netgenes = genes
	print('Training the model with the probability matrix...')
    #fit the model
	W, H = operator2.fit_transform()
    
   	#compute the clustering
	H_t = H.transpose()
	kmeans = cluster.KMeans(n_clusters=6).fit(H_t)
	predicted_labels = kmeans.labels_
    
    #compute the ARI
	ari = metrics.adjusted_rand_score(labels, predicted_labels)
	print("ARI: with probability matrix"+str(ari))
	
	#plot results
	points = TSNE(n_components=2, random_state=1).fit_transform(H_t)
	plt.scatter(points[:, 0], points[:, 1], c=predicted_labels, s=1, cmap='viridis')
	plt.title('Predicted labels with prob matrix')
	plt.show()
	

